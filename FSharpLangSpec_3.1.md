# F# 3.1 言語仕様(ワーキングドラフト)

> 原文： http://fsharp.org/specs/language-spec/3.1/FSharpSpec-3.1-working.docx

> 注釈：この文章はMicrosoftResearchおよびMicrosoftDeveloperDivisionによって
> 2013年6月に作成された、F# 3.1リリース向けの言語仕様です。

この言語仕様には3.1の実装と一致しない箇所がある場合があります。
文章中ではそれらの該当箇所にコメントの形でなるべく注釈を加えてあります。
言及のない不一致を見つけた場合は是非連絡してください。
そうすれば将来リリースされる言語仕様ではそれとわかるようにさせていただきます。
F#の開発チームはいつでもこの言語仕様、およびF#の設計や実装に対する
フィードバックを歓迎します。
フィードバックを送信するには、
http://github.com/fsharp/fsfoundation/docs/language-spec
にIssueをオープンしたり、コメントを追加したり、
Pull Requestを送信したりといった方法があります。

言語仕様の最新版は [fsharp.org](http://fsharp.org/) にあります。
これまでのドキュメントに対するF# ユーザーコミュニティからのフィードバックには
大変感謝しています。

この仕様書の一部ではC# 4.0やUnicode、IEEEといった仕様への言及があります。

**著者：**
Don Syme および補佐として Anar Alimov, Keith Battocchi, Jomo Fisher,
Michael Hale, Jack Hu, Luke Hoban, Tao Liu, Dmitry Lomov,
James Margetson, Brian McNamara, Joe Pamer, Penny Orwick,
Daniel Quirk, Kevin Ransom, Chris Smith, Matteo Taveggia,
Donna Malayeri, Wonseok Chae, Uladzimir Matsveyeu, Lincoln Atkinson
等による。

**警告**

_© 2005-2013 Microsoft Corporation and contributors. [Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0.html)ライセンスの下に利用出来ます。_

_Microsoft, Windows, Visual F#はアメリカ合衆国 Microsoft Corporationの商標、あるいはアメリカ合衆国内外における登録商標です。_

_文章内で言及されるその他の製品や会社名にはそれぞれ固有の所有者が存在する場合があります。_

**更新履歴**

* 2014年 5月 バージョン番号をF# 3.1に変更
* 2013年 6月 F# 3.1用の最初の更新 ([言語のアップデートに関するオンラインの議論](http://blogs.msdn.com/b/fsharpteam/archive/2013/06/27/announcing-a-pre-release-of-f-3-1-and-the-visual-f-tools-in-visual-studio-2013.aspx)を参照)
* 2012年 9月 F# 3.0用の更新
* 2012年 8月 書式の更新
* 2011年12月 文法の要約を更新
* 2011年 2月 用語集と索引の更新、書式の修正
* 2010年 8月 用語集と索引の更新、書式の修正

## 目次

// TODO

## 1. イントロダクション

F#はスケーラブルで簡潔かつ型安全で、型推論も行われ、実行効率もよい
関数型/宣言型/オブジェクト指向のプログラミング言語です。
この言語は.NET FrameworkおよびEcma 335 Common Language Infrastructure(CLI: 共通言語基盤)
の実装上で動作する、最初の型付き関数型プログラミング言語となるものです。
F#は部分的にOCaml言語から影響を受けており、一般的なコア部分においてOCamlと共通するものもあります。

### 1.1 最初のプログラム

以降のセクションでは、小さなF#プログラムを紹介して、
F#の重要な機能を説明していきます。
F#の最初の一歩として、以下のプログラムを見てみましょう：

```fsharp
let numbers = [ 1.. 10 ]

let square x = x * x

let squares = List.map square numbers

printfn "N^s = %A" squares
```

このプログラムは以下の方法で試すことができます：

* Visual Studioなどの開発環境上にて、プロジェクトとしてコンパイルする
* F#のコマンドラインコンパイラ`fsc.exe`を手動で実行する
* F#の配布物に同梱されている、動的コンパイラであるF# Interactiveを使用する

#### 1.1.1 軽量構文

F#言語では、軽量構文と呼ばれる、単純かつインデント重視の構文機能を使用します。
先ほどのセクションにあったサンプルのプログラムには一連の宣言文が並んでおり、
いずれも同じ列に揃えられていました。
たとえば以下のコードの2行はそれぞれ別の宣言文です：

```fsharp
let squares = List.map square numbers

printfn "N^2 = %A" squares
```

軽量構文はF#の構文の主要な部分すべてにおいて通用します。
次の例にあるコードは正しく整列されていません。
宣言文は1行目から始まって2行目以降に続いています。
そのため、2行目以降は同じ列に整列しなければいけません：

```text
let computeDerivative f x =
    let p1 = f (x - 0.05)
  let p2 = f (x + 0.05)
       (p2 - p1) / 0.1
```

正しく整列すると以下のようになります：

```fsharp
let computeDerivative f x =
    let p1 = f (x - 0.05)
    let p2 = f (x + 0.05)
    (p2 - p1) / 0.1
```

軽量構文は`.fs`, `.fsx`, `.fsi`, `.fsscript`の拡張子を持ったF#コードファイルにおける標準の構文です。

#### 1.1.2 データを簡単にする

サンプルの1行目では、単に1から10までの数のリストを宣言しています。

```fsharp
let numbers = [1 .. 10]
```

F#のリストは不変のリンクリストで、これは関数型プログラミングにおいて拡張可能なデータ型として使用されるものです。
この型には、リストの先頭に1つの要素を追加する`::`演算子や、
2つのリストを連結する`@`演算子といったものが用意されています。
F# Interactive上でこれらの演算子を試してみると以下のようになります：

```text
> let vowels = ['e'; 'i'; 'o'; 'u'];;
val vowels: char list = ['e'; 'i'; 'o'; 'u']

> ['a'] @ vowels;;
val it: char list = ['a'; 'e'; 'i'; 'o'; 'u']

> vowels @ ['y'];;
val it: char list = ['e'; 'i'; 'o'; 'u'; 'y']
```

F# Interactive上では2つのセミコロンで行が区切られることに注意してください。
また、それぞれの結果が変数ではなく不変の値だということを表す
_val_ という文字がF# Interactive上で出力されている点にも注意してください。

F#にはモデル化処理やデータ操作を簡単に行うことが出来るように、
タプルやオプション、レコード、共用体、シーケンス式といった、
きわめて効率のよいテクニックをサポートする機能が揃えられています。
タプルは順序つきの値のコレクションで、アトミックな単位で扱う事ができます。
多くの言語において、関連のある一連の値を1つのエンティティとしてあちこちに渡したい場合、
クラスやレコードなどのような名前の付いた型を用意して、そこに値を格納することになります。
一方、タプルを利用する場合には関連する値をグループとしてまとめるだけでよく、
新しく型を用意する必要はありません。

タプルは各コンポーネントをカンマ区切りに記述して定義します。

```text
> let tuple = (1, false, "text");;
val tuple : int * bool * string = (1, false, "text")

> let getNumberInfo (x : int) = (x, x.ToString(), x * x);;
val getNumberInfo : int -> int * string *int

> getNumberInfo 42;;
val it : int * string * int = (42, "42", 1764)
```

F#の重要なコンセプトは**不変性(immutability)**です。
タプルやリストはF#における多数の不変な型のうちの1つです。
実際、F#における多くの要素が標準的には不変です。
不変性とは、一度値が作成されてそれに名前が付けられると、
その名前に関連づけられた値を変えることができないということです。
不変性には利点がいくつかあります。
最も顕著なものは、いくつかのパターンのバグを防ぐ事ができること、
そして不変なデータは本質的にスレッドセーフであり、
並列処理を行うコードを簡単に記述できるようになるという点です。

#### 1.1.3 型を単純にする

サンプルプログラムの次の行では、入力値の2乗を計算する `square`
という名前の関数を定義しています。

```fsharp
let square x = x * x
```

静的型付け言語の多くは、関数を定義する際に型情報を明示的に指定する必要があります。
しかしF#の場合、基本的には型情報が推論されるようになっています。
この処理は**型推論**と呼ばれます。

型のシグネチャから、F#は `square` が `x` という名前の引数を1つとり、
`x * x` を返す関数だと認識します。
F#では、関数本体において最後に評価されたものが関数の返り値になります。
したがってこのコードにも \*return\* キーワードが出てきません。
多くのプリミティブ型( `byte` や `uint64` `double` など)において
積算(`*`)がサポートされています。
しかしF#において数値演算を行う場合、標準では `int` として型が推論されます。

F#はたいていの場合には自動的に型を推論するようになっていますが、
場合によっては明示的に型を指定する必要もあります。
たとえば以下のコードでは引数の1つに型注釈を指定して、
入力値の型をコンパイラに伝えています：

```text
> let concat (x : string) y = x + y;;
val concat : string -> string -> string
```

`x` が `string` 型だと宣言されていて、左辺に `string` 型をとる
`+` 演算子は右辺にも `string` 型をとるため、F# コンパイラによって
`y` も同じく `string` 型だと推論されます。
したがって `x + y` の結果は連結された文字列になります。
型注釈が無かった場合、F# コンパイラはどのバージョンの `+` を使うべきか
判断できないため、標準の動作として `int` 型のデータだとみなします。

型推論の処理によって、宣言が**自動汎化(automatic generalization)**
される場合もあります。
つまり可能であれば型が**ジェネリック**型になり、
多数の型を対象とすることができるコードとして定義されるということです。
たとえば以下のコードでは2つの値が入れ換えられている、新しいタプル型を返します：

```text
> let swap (x, y) = (y, x);;
val swap : 'a * 'b -> 'b -> 'a

> swap (1, 2);;
val it : int * int = (2, 1)

> swap ("you", true);;
val it : bool * string = (true, "you")
```

この`swap`はジェネリック関数で、`'a`と`'b`は**型変数**、
つまりジェネリックコードにおける型のプレースホルダーです。
型推論と自動汎化により、再利用可能なコードを
非常に単純に記述できるようになります。

#### 1.1.4 関数型プログラミング

サンプルプログラムでは、続けて`numbers`という整数のリストと
`square`関数、そしてリストの各要素に対して
この関数を適用した新しいリストを返す関数を定義しています。
この操作はリストの各要素に対して関数を**マッピング**すると表現されます。
F#ライブラリにある`List.map`がまさにこの処理に該当します：

```fsharp
let squares = List.map square numbers
```

別の例を見てみましょう：

```text
> List.map (fun x -> x % 2 = 0) [1 .. 5];;

val it : bool list
= [false; true; false; true; false]
```

このコードでは`(fun x -> x % 2 = 0)`という、**関数式**と呼ばれる
匿名関数を定義しています。
この関数式は引数`x`をとり、`x % 2 = 0`つまり`x`が偶数かどうかを
ブール値として返します。
`->`というシンボルは引数リスト(`x`)と関数の本体(`x % 2 = 0`)を区切るものです。

いずれの例においても、関数を別の関数の引数として渡しています。
つまり`List.map`の1番目の引数はそれ自体が別の関数だということです。
関数を**関数値**として使用できるということが
関数型プログラミングの特徴です。

データを変換したり分析したりする場合には、
**パターンマッチ**という方法もあります。
この強力な切り替え機能を使用すると、制御フローを切り替えたり
新しい値をバインドしたりすることができます。
たとえばF#のリストの場合、リスト内の一連の要素に対する
マッチングを行う事ができます。

```fsharp
let checkList alist =
    match alist with
    | [] -> 0
    | [a] -> 1
    | [a; b] -> 2
    | [a; b; c] -> 3
    | _ -> failwith "リストが長すぎます！"
```

この例では要素として取り得る各パターンに対して
`alist`がマッチするかどうかを比較しています。
`alist`がパターンに一致すると結果の式が評価されて、
マッチ式の値が返されます。
ここでの`->`はパターンと、マッチの結果返される値とを区切っています。

パターンマッチは制御フローとしても機能します。
たとえばパターンを使用して型が動的にキャスト可能かどうかを
チェックすることができます：

```fsharp
let getType (x : obj) =
    match x with
    | :? string           -> "xはstringです"
    | :? int              -> "xはintです"
    | :? System.Exception -> "xはexceptionです"
```

`:?`は値が特定の型に一致する場合にtrueを返します。
したがって`x`が文字列の場合、`getType`は「`xはstringです`」という値を返します。

関数値は**パイプライン演算子** `|>` を使用して連結することもできます。
たとえば以下の3つの関数があるとします：

```fsharp
let square x        = x * x
let toStr (x : int) = x.ToString()
let reverse (x : string) = new System.String(Array.rev (x.ToCharArray()))
```

これらの関数をパイプライン内の値として使用できます：

```text
> let result = 32 |> square |> toStr |> reverse;;
val it : string = "4201"
```

パイプラインのデモはF#が関数型プログラミングにおける重要なコンセプトである
**連結性(compositionality)**をサポートすることの一例になっています。
パイプライン演算子を使用すると、
1つの関数の結果が別の関数へと渡されるような、
組み合わされたコードを簡単に記述できるようになります。

#### 1.1.5 宣言的プログラミング

