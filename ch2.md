## <a name="section_2">2. プログラムの構造

F#コンパイラまたはF# Interactive動的コンパイラには以下を入力します：

* 拡張子 `.fs` `.fsi` `.fsx` `.fsscript` を持ったソースコードファイル
  * 拡張子 `.fs` のファイルには[§12.1](#section_12_1)
    で説明している文法要素`implementation-file`が含まれるものとします。
  * 拡張子 `.fsi` のファイルには[§12.2](#section_12_2)
    で説明している文法要素`signature-file`が含まれるものとします。
  * 拡張子 `.fsx` または `.fsscript` のファイルには[§12.3](#section_12_3)
    で説明している文法要素`script-file`が含まれるものとします。
* (F# Interactive用の)スクリプトフラグメント(サイズの小さいコード)。
  このコードは文法要素`script-fragment`と一致していなければいけません。
  スクリプトフラグメントは区切り文字`;;`によって区切られます。
* コマンドライン引数、またはコード内のディレクティブによって指定された
  アセンブリへの参照。
* コマンドライン引数、またはコード内のディレクティブによって指定された
  コンパイルオプション。
* `#time`のようなコンパイラ用ディレクティブ。

コンパイル時シンボル`COMPILED`はF#コンパイラが入力を処理する場合に定義されます。
一方、F# Interactiveが処理する場合には`INTERACTIVE`が定義されます。

入力されたソースコードは以下の順で処理されます：

1. ***デコード(Decoding)***: 各ファイルおよびソースコード片は
   C#の言語仕様セクション2.3および2.4にある説明と同じく、
   Unicode文字のストリームとしてデコードされます。
   この処理を実行する際に使用するコードページは
   コマンドライン引数として指定できる場合があります。
2. ***トークン化(Tokenization)***: Unicode文字のストリームは
   [§3](#section_3)で説明している字句解析(lexical analysis)
   によってトークンのストリームへと分解されます。
3. ***字句フィルタ(Lexical Filtering)***: トークンのストリームは
   [§15](#section_15)で説明している規則を実装しているステートマシンによって
   フィルタされます。
   これらのルールにはトークンのストリームに(人工的な)トークンを追加する方法や、
   既存のトークンをどの別のトークンで置き換えて新しい(拡張された)トークンストリームを
   生成するのかといった方法が含まれます。
4. ***解析(Parsing)***: 拡張後のトークンのストリームは本ドキュメントにより
   定義されている文法に従って解析されます。
5. ***インポート(Importing)***: インポートされたアセンブリ参照は
   F#またはCLIのアセンブリ仕様に準じて解決された後、インポートされます。
   F#の観点からすると、これによって様々な名前空間宣言グループ
   ([§12.1](#section_12_1))や型の事前定義が読み込まれます。
   そしてこの名前空間宣言グループは組み合わされて
   最初の名前解決環境([§14.1](#section_14_1))を形成することになります。
6. ***チェック(Checking)***: 解析結果は1つずつチェックされます。
   チェックには名前解決([§14.1](#section_14_1))や
   制約の解決([§14.5](#section_14_5))、
   一般化([§14.6.7](#section_14_6_7))といった処理の他に、
   本ドキュメントで説明されているその他のルールを適用することも含まれています。

   型推論では、型の推論に未知の問題があったことを表す値が使用されます。
   様々なチェック処理を行っている間、名前解決環境や現在の推論に関する一連の制約
   というような、文脈依存の情報を含んだテーブルが管理されます。
   ファイルまたはプログラム片の処理が完了すると、
   これらの値は汎化あるいは解決済みとなり、型推論環境は破棄されます。
7. ***仕上げ(Elaboration)***: チェックを行った結果の1つとして、
   仕上げ済みの宣言や式、型を含むようなプログラム片が仕上がります。
   定数や制御フロー、データ式など、たいていの制約に対する仕上げ済みの形式は
   単純な形になっています。
   仕上げ済みの形式は評価やCLIリフレクション、クオート式([§6.8](#sectioN_6_8))
   から返されるF#の式ツリーなどのために使用されます。
8. ***実行(Execution)***: チェックが問題無く完了した、仕上げ済みのプログラム片は
   実行可能なプログラム片のコレクションに追加されます。
   各プログラム片は静的初期化子(static initializer)を持ちます。
   静的初期化子は([§12.5](#section_12_5))にある説明に従って実行されます。
